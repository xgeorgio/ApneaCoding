Title:<br/>
<b>River crossing puzzle in Prolog</b>

Description:<br/>
<p>This program is a simple demonstration for illustrating how classic declarative programming can provide very intuitive and compact solution generators for logic problems and combinatorial tasks. In this classic puzzle, a farmer needs to plan for a sequence of 'safe' river crossings, given the constraints: (a) the boat has capacity of only two, (b) the farmer has to be in the boat in all crossings, (c) goat eats cabbage, (d) wolf eats goat, (e) 'eat' is negated only where the farmer is present (on river side). The task is to find a safe way to execute the required transfer, given a starting and an ending set of items in each river side. In this case, the pairs goat/cabbage and goat/wolf should never happen unattended in any river side during the transfers.</p>
<p>Prolog's main advantage over other declarative programming languages is that even in the early '80s came with a rich library of common functionalities that made real-world application development easy. Turbo Prolog was probably the best option for PC machines, with efficient memory enhancements via more strict typing and other syntax shortcuts to limit the tree search in manageable space/time requirements for these platforms. Although now depricated by constrained and fuzzy logic paradigms, Prolog-style programming is still the most intuitive way to design simple expert systems and knowledge management platforms.</p>
